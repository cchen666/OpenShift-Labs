#### Get Certificate
~~~
$ curl -v https://registry.redhat.io

* successfully set certificate verify locations:
*   CAfile: /etc/ssl/cert.pem   <=== Trusted CA list file

<Snip of cert.pem>

### /C=ES/CN=Autoridad de Certificacion Firmaprofesional CIF A62634068

=== /C=ES/CN=Autoridad de Certificacion Firmaprofesional CIF A62634068
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 6047274297262753887 (0x53ec3beefbb2485f)
    Signature Algorithm: sha1WithRSAEncryption
        Validity
            Not Before: May 20 08:38:15 2009 GMT
            Not After : Dec 31 08:38:15 2030 GMT
        Subject: C=ES, CN=Autoridad de Certificacion Firmaprofesional CIF A62634068
        X509v3 extensions:
            X509v3 Basic Constraints: critical
                CA:TRUE, pathlen:1   <==== This is CA's cert so marked as CA:TRUE. For server's cert you'll find CA:FALSE

$ openssl s_client -connect registry.redhat.io:443 | openssl x509 -text
$ curl -v https:// --cacert <certificate>
~~~
#### Cert Types
* User-Provided Api: service-ca cluster operator is responsible to create a CA and signs the cert. There can be alternative certs for Api. The cert is 30 days valid
~~~
$ openssl s_client -connect api.mycluster.nancyge.com:6443 | openssl x509 -text
Signature Algorithm: sha256WithRSAEncryption
    Issuer: OU=openshift, CN=kube-apiserver-service-network-signer
Validity
    Not Before: May 14 04:42:24 2021 GMT
    Not After : Jun 13 04:42:25 2021 GMT
    X509v3 extensions:
        X509v3 Key Usage: critical
            Digital Signature, Key Encipherment
        X509v3 Extended Key Usage:
            TLS Web Server Authentication
        X509v3 Basic Constraints: critical
            CA:FALSE
~~~
* Api
~~~
Control plane certificates are managed by the system and rotated automatically.
Api  Certificate - the certificate presented by the API server for external requests
Api-int Certificate - the certificate presented by the API server for cluster-internal communication
Retrieve Certificates from the secrets and the location on masters.

$ oc get secret -n openshift-kube-apiserver external-loadbalancer-serving-certkey -o yaml -o=custom-columns=":.data.tls\.crt" | tail -1 | base64 -d | openssl x509 -text

Signature Algorithm: sha256WithRSAEncryption
    Issuer: OU=openshift, CN=kube-apiserver-lb-signer
    Validity
        Not Before: May 14 04:42:24 2021 GMT
        Not After : Jun 13 04:42:25 2021 GMT
    Subject: CN=api.mycluster.nancyge.com

oc get secret -n openshift-kube-apiserver internal-loadbalancer-serving-certkey -o yaml -o=custom-columns=":.data.tls\.crt" | tail -1 | base64 -d | openssl x509 -text

Signature Algorithm: sha256WithRSAEncryption
    Issuer: OU=openshift, CN=kube-apiserver-lb-signer
    Validity
        Not Before: May 14 04:42:44 2021 GMT
        Not After : Jun 13 04:42:45 2021 GMT
    Subject: CN=api-int.mycluster.nancyge.com


~~~
* Proxy
#### docs
https://docs.openshift.com/container-platform/4.7/security/certificate_types_descriptions/user-provided-certificates-for-api-server.html
* service-ca
~~~
The applications which requires TLS certificates out of the box for secure communication can use the service serving certificates. The TLS certificate generated by Service CA gets mounted at /var/serving-cert/ inside the pod with the name tls.crt and tls.key. So the application must be developed in such a way that it uses those certificates from the particular directory. The certificate and key are mounted from the secret which gets created by the Service CA operator

Service CA certificate which signs serving certificate can be found inside openshift-service-ca.

$ oc get secret -n openshift-service-ca signing-key -o=custom-columns=":.data.tls\.crt" | tail -1 | base64 -d | openssl x509 -text -noout

To secure communication to the service, generate a signed serving certificate and key pair into a secret in the same namespace as the service.

$ oc annotate service <service-name> \
         service.beta.openshift.io/serving-cert-secret-name=<secret-name>
~~~
* Node certificates
~~~
openssl x509 -in /var/lib/kubelet/pki/kubelet-client-current.pem -text
~~~
~~~
Node certificates are expired or having some other issue

1. We need to create a bootstrap kubeconfig . To do so, run the following from a place with cluster-admin access:

oc -n openshift-machine-config-operator serviceaccounts create-kubeconfig node-bootstrapper  > kubeconfig

2. SSH to the master and become root

3. Stop kubelet: systemctl stop kubelet

4. Backup and remove the following files:

mv /var/lib/kubelet/kubeconfig{,.old}
mv /var/lib/kubelet/pki{,.old}
mkdir /var/lib/kubelet/pki

5. Copy the bootstrap kubeconfig created at step 1 to /etc/kubernetes/kubeconfig

6. Start kubelet: systemctl start kubelet

7. In a place with cluster-admin access to the cluster, check whether new CSRs are generated (via "oc get csr --all-namespaces") and approve those which are not approved automatically (via "oc adm certificate approve <csr-name>"). At least 2 CSRs must be generated (each one may take some minutes)
~~~
* etcd certificate
~~~
etcd certificates are signed by the etcd-signer; they come from a certificate authority (CA) that is generated by the bootstrap process.

The CA certificates are valid for 10 years. The peer, client, and server certificates are valid for three years.

etcd certificates are used for encrypted communication between etcd member peers, as well as encrypted client traffic. The following certificates are generated and used by etcd and other processes that communicate with etcd:

Peer certificates: Used for communication between etcd members.

Client certificates: Used for encrypted server-client communication. Client certificates are currently used by the API server only, and no other service should connect to etcd directly except for the proxy. Client secrets (etcd-client, etcd-metric-client, etcd-metric-signer, and etcd-signer) are added to the openshift-config, openshift-monitoring, and openshift-kube-apiserver namespaces.

Server certificates: Used by the etcd server for authenticating client requests.

Metric certificates: All metric consumers connect to proxy with metric-client certificates.

~~~
* Ingress
https://docs.openshift.com/container-platform/4.7/security/certificates/replacing-default-ingress-certificate.html
~~~

$ openssl s_client -connect deploy-python-openshift-tutorial-myproject.apps.mycluster.nancyge.com:443 | openssl x509 -text

Signature Algorithm: sha256WithRSAEncryption
    Issuer: CN=ingress-operator@1619671406
    Validity
        Not Before: Apr 29 04:43:27 2021 GMT
        Not After : Apr 29 04:43:28 2023 GMT
    Subject: CN=*.apps.mycluster.nancyge.com

~~~
#### Redeploy Resources similar to etcd because of cert issue
~~~
Control Plane Cert issue on 1 master node.

To force deployment of kubeaapiserver pods run below command :
# oc patch kubeapiserver/cluster --type merge -p "{\"spec\":{\"forceRedeploymentReason\":\"Forcing new revision with random number $RANDOM to make message unique\"}}"

Similarly for kubecontroller manager :
# oc patch kubecontrollermanager cluster -p='{"spec": {"forceRedeploymentReason": "recovery-'"$( date --rfc-3339=ns )"'"}}' --type=merge

Kubescheduler :
# oc patch kubescheduler cluster -p='{"spec": {"forceRedeploymentReason": "recovery-'"$( date --rfc-3339=ns )"'"}}' --type=merge"
Installer Controller
https://github.com/openshift/cluster-kube-apiserver-operator/blob/master/vendor/github.com/openshift/library-go/pkg/operator/staticpod/controller/installer/installer_controller.go
Installer Pod yaml
https://github.com/openshift/origin/blob/master/vendor/github.com/openshift/library-go/pkg/operator/staticpod/controller/installer/manifests/installer-pod.yaml
~~~
